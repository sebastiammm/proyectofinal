@page "/"
@inject HttpClient HttpClient
@inject NavigationManager NavigationManager
@inject OrderState OrderState
@layout MainLayout
@implements IDisposable 

<div class="main">
    <div class="product-grid">
        @if (specials != null)
        {
            @foreach (var special in specials)
            {
                <div class="product-card" @onclick="@(() => OrderState.ShowConfigurePizzaDialog(special))">

                    <img class="product-image" src="@special.ImageUrl" alt="@special.Name" />

                    <div class="product-info">
                        <span class="title">@special.Name</span>
                        @special.Description
                        <span class="price">@special.GetFormattedBasePrice()</span>
                    </div>
                </div>
            }
        }
    </div>  
</div>
<div class="sidebar @(order.Pizzas.Any() ? "is-visible" : "") @(isMinimized ? "minimized" : "") @(isFalling ? "is-falling" : "")">
    <div class="chain chain-left"></div>
    <div class="chain chain-right"></div>
    @if (order.Pizzas.Any())
    {
        <div class="cart-view-maximized @(isMinimized ? "hidden" : "")">

            <h2 @onclick="ToggleMinimize">
                Tu orden

                <button class="btn-remove-all" @onclick="ClearCartAndFall" @onclick:stopPropagation="true">
                    <i class="fa-solid fa-trash-can"></i>
                </button>

                <i class="fa-solid fa-chevron-down"></i>
            </h2>

            <div class="order-contents">
                @foreach (var configuredPizza in order.Pizzas)
                {
                    <div class="cart-item">
                        <div class="title">@(configuredPizza.Size)" @configuredPizza.Special.Name</div>
                        <div class="item-price">
                            @configuredPizza.GetFormattedTotalPrice()
                        </div>
                        <a @onclick="@(() => OrderState.RemoveConfiguredPizza(configuredPizza))" class="delete-item">x</a>
                    </div>
                }
            </div>

            <div class="order-total">
                Total:
                <span class="total-price">@order.GetFormattedTotalPrice()</span>
                <a href="checkout" class="btn btn-warning">
                    Order >
                </a>
            </div>
        </div>

        <div class="cart-view-minimized @(isMinimized ? "" : "hidden")" @onclick="ToggleMinimize">
            <span>Total: @order.GetFormattedTotalPrice()</span>
            <i class="fa-solid fa-chevron-up"></i>
        </div>
    }
    else
    {
        <div class="empty-cart">
            <h2>Tu pedido</h2>
            <div class="empty-cart-message">
                Elija su Pizza<br>para empezar
            </div>
        </div>
    }
</div>

@if (OrderState.ShowingConfigureDialog)
{
    <ConfigurePizzaDialog
      Pizza="OrderState.ConfiguringPizza"
      OnCancel="OrderState.CancelConfigurePizzaDialog"
      OnConfirm="OrderState.ConfirmConfigurePizzaDialog" />
}

@code {
    List<PizzaSpecial> specials = new List<PizzaSpecial>();
    Order order => OrderState.Order;
    bool isMinimized = false;

    void ToggleMinimize()
    {
        isMinimized = !isMinimized;
    }

    // --- AÑADE ESTA VARIABLE ---
    bool isFalling = false;

    // ... (tu función ToggleMinimize() existente) ...

    // --- AÑADE ESTA NUEVA FUNCIÓN ---
    async Task ClearCartAndFall()
    {
        // 1. Activa la animación
        isFalling = true;

        // 2. Espera 600ms para que la animación CSS termine
        await Task.Delay(600);

        // 3. Limpia la orden (esto hará que el carrito se oculte)
        OrderState.ResetOrder();

        // 4. Resetea el estado de la animación
        isFalling = false;
    }

    // El método OnInitializedAsync con la suscripción al evento
    protected override async Task OnInitializedAsync()
    {
        specials = await HttpClient.GetFromJsonAsync<List<PizzaSpecial>>(NavigationManager.BaseUri + "specials");

        // Se suscribe al evento OnChange de OrderState
        // Cuando OrderState avisa, Blazor refresca esta página (StateHasChanged)
        OrderState.OnChange += StateHasChanged;
    }
    // --- ¡EL MÉTODO QUE FALTABA! ---
    // Esto se ejecuta cuando sales de la página Index.
    // Es crucial para "desuscribirse" del evento y evitar fugas de memoria.
    public void Dispose()
    {
        OrderState.OnChange -= StateHasChanged;
    }
}
		